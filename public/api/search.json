[{"id":"8fd9bc806036d8ae8c47b44f69c0de01","title":"RNAseq 数据预处理的常规流程","content":"RNAseq 数据预处理的常规流程目录\n环境设置\n数据展示\n数据质量检测\n过滤低表达基因\n数据标准化\n去批次\n处理后质量检测\n\n0. 环境设置读入本次实验需要用到的数据包。\nrlibrary(tidyverse) # 格式整理\nlibrary(data.table) # 读入文件\nlibrary(clusterProfiler) # Gene ID 转换为 Gene Symbol\nlibrary(org.Hs.eg.db) # 人类基因组注释文件\nlibrary(FactoMineR) # 计算 PCA\nlibrary(factoextra) # PCA 画图\nlibrary(pheatmap) # 热图\nlibrary(ggplot2) # 画图\nlibrary(reshape2) # 长宽表转换\nlibrary(edgeR) # 去除低表达基因 1. 数据展示此次演示中使用来自 GSE222699 的 RNAseq 数据，数据从 GEO 官网下载。\ntxtGSE222699_RAW\n├─ GSM6929162_HDMB03_CTRL_1.txt.gz\n├─ GSM6929163_HDMB03_CTRL_2.txt.gz\n├─ GSM6929164_HDMB03_CTRL_3.txt.gz\n├─ GSM6929165_HDMB03_CTRL_4.txt.gz\n├─ GSM6929166_HDMB03_CTRL_1.txt.gz\n├─ GSM6929167_HDMB03_CTRL_2.txt.gz\n├─ GSM6929168_HDMB03_CTRL_3.txt.gz\n└─ GSM6929169_HDMB03_CTRL_4.txt.gz1.1 读入数据这组数据并没有将所有样本整合为一个表达矩阵，而是每个样本各有一个文件，因此我们首先整理表达矩阵。\nr# 将所有文件列入一个列表\nfiles &lt;- list.files(\n    path = \"data/GSE222699_RAW/\",\n    full.names = TRUE\n)\n\n# 读入列表中的第一个文件作为模板\n# 因为文件属于 .gz 压缩文件，直接用 fread 读入后再转换为 data.frame，这是一种更方便的操作\ncounts &lt;- fread(files[[1]]) %&gt;%\n    as.data.frame()\n\n# 从第二个文件开始，读入后与前几个文件合并\nfor (file in files[2:length(files)]) {\n    tmp &lt;- fread(file) %&gt;%\n        as.data.frame()\n    counts &lt;- merge(counts, tmp, by = \"V1\")\n}\n\n# 查看合并后的表达矩阵\nView(counts)\n\n\n\nV1\nHDMB03_shCTRL_1\nHDMB03_shCTRL_2\nHDMB03_shCTRL_3\nHDMB03_shCTRL_4\nHDMB03_shPPHLN1_1\nHDMB03_shPPHLN1_2\nHDMB03_shPPHLN1_3\nHDMB03_shPPHLN1_4\n\n\n\n1\nENSG00000000003\n1041\n966\n828\n1053\n1334\n1563\n1157\n1258\n\n\n2\nENSG00000000005\n0\n0\n0\n0\n0\n0\n0\n0\n\n\n3\nENSG00000000419\n1118\n1382\n999\n1414\n1140\n1648\n1067\n1168\n\n\n4\nENSG00000000457\n315\n394\n369\n344\n482\n595\n435\n388\n\n\n5\nENSG00000000460\n447\n436\n439\n411\n479\n635\n496\n339\n\n\n6\nENSG00000000938\n0\n0\n0\n0\n0\n0\n0\n0\n\n\n1.2 Gene ID 转换为 Gene Symbol可以看到，合并后的矩阵以 Gene ID 表示基因，这不利于我们后续对基因的阅读，需要转换为方便阅读的 Gene Symbol。\nr# 通过 clusterProfiler 中的 bitr() 函数将 Gene ID 与 Symbol 一一对应\n# drop = FALSE 是指无法 mapping 到 Symbol 的 Gene ID 依然保留在表中，方便后续的合并\n# 如果 drop = TRUE，那么无法 mapping 的 Gene ID 会被舍去，id2symbol 的顺序就会和 counts 不同，不利于合并\nid2symbol &lt;- bitr(\n    geneID = counts$V1,\n    fromType = \"ENSEMBL\",\n    toType = \"SYMBOL\",\n    OrgDb = org.Hs.eg.db,\n    drop = FALSE\n)\n\n# 消除对应到多个 Symbol 的 Gene ID，只保留 mapping 到的第一个 Symbol\n# duplicated() 代表重复的元素，对其取反 !duplicated() 代表不重复的元素\nid2symbol &lt;- id2symbol[which(!duplicated(id2symbol$ENSEMBL)), ]\n\n# 比对 id2symbol 与 counts 是否一一对应\ntable(id2symbol$ENSEMBL == counts$V1) # TRUE\n\n# 将 Gene Symbol 合并入 counts\ncounts$Symbol &lt;- id2symbol$SYMBOL\n\n# 去除没有 mapping 到的 Gene ID\n# na.omit() 去除包含 NA 的行\ncounts &lt;- na.omit(counts)\n\n# 查看 ID 转换后的表达矩阵\nView(counts)\n\n\n\nV1\nHDMB03_shCTRL_1\nHDMB03_shCTRL_2\nHDMB03_shCTRL_3\nHDMB03_shCTRL_4\nHDMB03_shPPHLN1_1\nHDMB03_shPPHLN1_2\nHDMB03_shPPHLN1_3\nHDMB03_shPPHLN1_4\nSymbol\n\n\n\n1\nENSG00000000003\n1041\n966\n828\n1053\n1334\n1563\n1157\n1258\nTSPAN6\n\n\n2\nENSG00000000005\n0\n0\n0\n0\n0\n0\n0\n0\nTNMD\n\n\n3\nENSG00000000419\n1118\n1382\n999\n1414\n1140\n1648\n1067\n1168\nDPM1\n\n\n4\nENSG00000000457\n315\n394\n369\n344\n482\n595\n435\n388\nSCYL3\n\n\n5\nENSG00000000460\n447\n436\n439\n411\n479\n635\n496\n339\nFIRRM\n\n\n6\nENSG00000000938\n0\n0\n0\n0\n0\n0\n0\n0\nFGR\n\n\n1.3 消除重复的基因多个 Gene ID 常常对应到同一个 Gene Symbol，导致矩阵中出现重复的基因名，需要想办法去除。\nr# 去除 Gene ID 这一列\n# [, -1] 代表去除第一列\ncounts &lt;- counts[, -1]\n\n# 取出重复的基因与不重复的基因\n# 查看有多少重复的基因\ntable(duplicated(counts$Symbol))\n\n# 取出重复基因所在的行号\ndupl &lt;- duplicated(counts$Symbol)\n\n# 取出重复的基因名\ngeneDupl &lt;- counts$Symbol[dupl]\n\n# 取出重复的基因所在的行\n# 这边不直接使用 duplicated() 函数，是因为 duplicated() 函数不会取出第一项重复的元素\n# 比如如果一个元素共重复了 5 次， duplicated() 只会取出后 4 次，而忽略第 1 次\ncountsDupl &lt;- subset(\n    x = counts,\n    subset = Symbol %in% geneDupl\n)\n\n# 不在 geneDupl 中的基因则认为是 unique 的基因\ncountsUniq &lt;- subset(\n    x = counts,\n    subset = !(Symbol %in% geneDupl)\n)\n\n# 合并重复的基因\n# 合并的方法有很多种，包括：均数 mean，中位数 median，最大值 max\n# 因为此处的数据类型为 Raw counts，为了尽量保护其整数性，此处选择使用 median\ncountsDupl &lt;- aggregate(\n    x = .~Symbol,\n    data = countsDupl,\n    FUN = median\n)\n\n# 将合并好的重复基因与非重复基因合并，得到完整的表达矩阵\ncounts &lt;- rbind(\n    countsDupl, countsUniq,\n    deparse.level = 2\n)\n\n# 将 Gene Symbol 转换为行名\ncounts &lt;- counts %&gt;%\n    remove_rownames() %&gt;%\n    column_to_rownames(var = \"Symbol\")\n\n# Counts 取整数\n# 即使是使用 median 处理重复基因，也难以避免 .5 的出现，因此依然需要四舍五入 round()\ncounts &lt;- round(counts)\n\n# 查看处理后的表达矩阵\nView(counts)\n\n\n\nHDMB03_shCTRL_1\nHDMB03_shCTRL_2\nHDMB03_shCTRL_3\nHDMB03_shCTRL_4\nHDMB03_shPPHLN1_1\nHDMB03_shPPHLN1_2\nHDMB03_shPPHLN1_3\nHDMB03_shPPHLN1_4\n\n\n\nARL17A\n84\n90\n88\n70\n98\n103\n102\n78\n\n\nBAZ2B\n694\n730\n674\n734\n672\n930\n778\n752\n\n\nBOLA2\n2\n0\n2\n6\n0\n0\n0\n0\n\n\nCCNYL6\n1\n2\n0\n1\n0\n0\n1\n3\n\n\nCKMT1B\n490\n726\n641\n476\n554\n622\n524\n396\n\n\nCRHR1\n22\n18\n32\n40\n24\n43\n36\n26\n\n\n2. 数据质量检测2.0 分组该数据共分为 2 组，4 个对照组 Ctrl 与 4 个实验组 PPHLN1。\nrgroup &lt;- data.frame(\n    group = rep(\n        x = c(\"Ctrl\", \"PPHLN1\"), # 2 组\n        each = 4 # 各 4 个\n    ),\n    row.names = colnames(counts) # 行名即样本名\n)2.1 PCAPCA （主成分分析）是一种数据降维方法。\n\n首先，所有的数据以其每个基因为基底，张成一个高维空间，而每个样本在这个高维空间中具有一个唯一的坐标 (x1, x2, … , xn)：\n计算高维空间中各个方向上样本间的方差，取方差最大的方向上的向量作为其主成分向量，记作 PC_1；\n显然，在 PC_1 上，样本的分布最为分散，不同样本间的区分度也就最高；\n\n\n在垂直于 PC_1 的各个方向上，取方差最大的方向上的向量，记作 PC_2：\nPC_1 与 PC_2 共同张成一个正交的二维平面；\n显然，在这一平面上，各个样本间的分布最为分散，不同样本间的区分度也就最高；\n\n\n在由 PC_1 与 PC_2 张成的二维平面上考察不同分组的样本的分布模式，理想的情况下：\n处于同一分组的样本之间的位置最为接近；\n处于不同分组的样本之间的位置相距最远。\n\n\n\nrpcaBefore &lt;- PCA(\n    X = t(counts),\n    graph = FALSE # 计算时不画图\n)\npicPcaBefore &lt;- fviz_pca_ind(\n    X = pcaBefore,\n    col.ind = group$group, # 规定各组的颜色\n    repel = TRUE, # 文字标签之间不重叠\n    addEllipses = TRUE # 加入椭圆形，每组不多于 3 个样本时无法加入椭圆\n                       # （五点确定一个椭圆，因此至少需要五个自由度，而对于不精确的拟合，可以只用 4 个点）\n)\nprint(picPcaBefore)\n\n2.2 相关性热图计算各个样本之间的相关性，以热图的形式展示，理想情况下：\n\n同属一组的样本之间相关性最高；\n属于不同组的样本之间相关性最低。\n\nrpicHeatmapBefore &lt;- pheatmap(\n    mat = counts %&gt;% cor(), # 计算相关性矩阵\n    annotation_row = group, # 行色块标签，表示分组\n    annotation_col = group, # 列色块标签，表示分组\n    legend = TRUE, # 显示色条图注\n    annotation_legend = FALSE, # 不显示分组图注\n    cutree_rows = 2, # 根据树状图分为两行\n    cutree_cols = 2, # 根据树状图分为两列\n    color = colorRampPalette(c(\"blue\", \"white\", \"red\"))(100) # 规定颜色为 (蓝, 白, 红)，过渡为 100\n)\nplot.new() # 新建画布\nprint(picHeatmapBefore) # 画图\n\n2.3 箱线图通过箱线图表示各个样本的分布，以考察各个样本是否属于同分布；\n若样本间的分布不同，不利于后续的统计学分析，需要进行标准化；\n由于 Raw counts 符合负二项分布，因此需要取 log2(counts+1) 使其接近正态分布。\nrpicBoxplotBefore &lt;- (counts+1) %&gt;% log2() %&gt;% # 取 log2(counts+1)\n    melt() %&gt;% # 将宽表形式的表达矩阵转换为长表形式，便于画图\n    ggplot + # 画图开始\n    geom_boxplot( # 画箱线图\n        mapping = aes(\n            x = variable, # x 轴为样本\n            y = value # y 轴为基因表达量\n        )\n    ) +\n    labs(x = \"Sample\", y = \"Expression\") + # 指定 x 轴与 y 轴的标题\n    theme_bw() + # 方框空白主题\n    theme(\n        axis.text.x = element_text(angle = 45, hjust = 1) # x 轴标签旋转 45 度并右对齐\n    )\nplot.new() # 新建画布\nprint(picBoxplotBefore) # 画图\n\n3. 过滤低表达基因观察到箱线图中的中位数线位于 0，说明存在大量低表达甚至不表达的基因；\n考虑到  无意义，会影响后续的差异倍数的计算；\n因此需要去除低表达的基因；\n此处使用 edgeR 包中的 filterByExpr() 函数。\nr# 过滤低表达基因\nkeep &lt;- filterByExpr(\n    counts,\n    group = group$group\n)\n\n# 取出过滤后仍保留的行\ncountsRLE &lt;- counts[keep, ]\n\n# 制图\npicBoxplotRLE &lt;- (countsRLE+1) %&gt;% log2() %&gt;% # log2(counts+1)\n    melt() %&gt;%\n    ggplot +\n    geom_boxplot(\n        mapping = aes(\n            x = variable,\n            y = value\n        )\n    ) +\n    labs(x = \"Sample\", y = \"Expression\") +\n    theme_bw() +\n    theme(\n        axis.text.x = element_text(angle = 45, hjust = 1)\n    )\n\n# 画图\nprint(picBoxplotRLE)\n\n经过过滤低表达基因后，可以看到，箱线图中的中位数线位于箱子的正中间，说明现在的表达量分布接近正态分布。\n4. 数据标准化观察经过过滤后的箱线图，可以发现，虽然大体上的分布趋势相似，但是箱子的高度仍然有细微的差别；\n我们可以使用 limma 包中的 normalizeBetweenArrays() 函数进行优化\nrcountsNorm &lt;- normalizeBetweenArrays(countsRLE)\npicBoxplotAfter &lt;- (countsNorm+1) %&gt;% log2() %&gt;%\n    melt() %&gt;%\n    ggplot +\n    geom_boxplot(\n        mapping = aes(\n            x = Var2,\n            y = value\n        )\n    ) +\n    labs(x = \"Sample\", y = \"Expression\") +\n    theme_bw() +\n    theme(\n        axis.text.x = element_text(angle = 45, hjust = 1)\n    )\nprint(picBoxplotAfter)\n\n可以看到，经过标准化后的数据分布完全一致，有利于我们下一步的分析\n5. 去批次此次实验中的样本全部来自一次测序结果，因此不存在批次效应；\n若实验中的样本是多次测序汇总的结果，则不同的测序批次之间存在批次效应，需要去除；\n去除批次效应可以使用 sva 包中的 ComBat() 函数以及 limma 包中的 removeBatchEffect() 函数；\n因为后续的差异分析主要基于 limma 包，因此此处也主要介绍 limma 包中的方法。\nr# 将分组信息转化为实验设计矩阵\ndesign &lt;- model.matrix(~0+group$group)\n\n# 提供批次信息\nbatch &lt;- data.frame(\n    batch = c(...) # 此处填入批次信息\n    row.names = col.names(countsNorm) # 行名来自样本名\n)\n\n# 去批次\ncountsRBE &lt;- removeBatchEffect(\n    counts,\n    batch = batch$batch, # 去除批次效应\n    design = design # 保留生物学效应\n)去批次后，可以再使用 PCA 方法验证去批次的效果。\n6. 处理后质量检测同样使用 PCA、相关性热图、箱线图三种方法；\n代码不赘述\n\n\n\n\n","slug":"RNAseq-数据预处理的常规流程","date":"2024-07-12T06:54:56.000Z","categories_index":"生物信息学","tags_index":"生物信息学,bulk seq","author_index":"明明钟"}]