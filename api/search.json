[{"id":"958a2e2692f83867182a03c26b1ec044","title":"Limma 差异分析的一般流程","content":"Limma 差异分析的一般流程目录\n环境配置\n实验设计与数据标准化\nlimma 的标准流程\n火山图的绘制\n表达热图的绘制\n\n0. 环境配置0.1 加载数据包rlibrary(tidyverse)\nlibrary(limma)\nlibrary(ggplo2)\nlibrary(pheatmap)0.2 数据预览在上一篇文章中，我们已经将数据整理为了标准化后的表达矩阵\n\n\n\n\nHDMB03_shCTRL_1\nHDMB03_shCTRL_2\nHDMB03_shCTRL_3\nHDMB03_shCTRL_4\nHDMB03_shPPHLN1_1\nHDMB03_shPPHLN1_2\nHDMB03_shPPHLN1_3\nHDMB03_shPPHLN1_4\n\n\n\nARL17A\n84\n90\n88\n70\n98\n103\n102\n78\n\n\nBAZ2B\n694\n730\n674\n734\n672\n930\n778\n752\n\n\nBOLA2\n2\n0\n2\n6\n0\n0\n0\n0\n\n\nCCNYL6\n1\n2\n0\n1\n0\n0\n1\n3\n\n\nCKMT1B\n490\n726\n641\n476\n554\n622\n524\n396\n\n\nCRHR1\n22\n18\n32\n40\n24\n43\n36\n26\n\n\n1. 实验设计与数据标准化1.1 实验设计所谓实验设计就是实验组与对照组的设置，通常 limma 处理的是单因素两组或多组的实验设计\nr# 设置分组向量\ngroup &lt;- data.frame(\n    group = rep(\n        x = c(\"Ctrl\", \"PPHLN1\"), # 2 组\n        each = 4 # 各 4 个\n    ),\n    row.names = colnames(counts) # 行名即样本名\n)\n\n# 将分组向量转化为 dummy variables\ndesign &lt;- model.matrix(~0+group$group)\n\n# 修改 design 表的行名与列名，与样本相对应\ncolnames(design) &lt;- unique(group$group)\nrownames(design) &lt;- colnames(countsNorm)1.2 数据标准化之前已经提过，counts 数据符合负二项分布，而良好的差异分析的输入则要求符合正态分布，因此这里有三种方法进行标准化\n1.2.1 VoomVoom 是 limma 自带的缩放方法，其本质是 ；\n其中 CPM 的计算方法如下式,  代表第 i 个基因的表达量：\n\n这相当于将某个基因的表达量转化为其在所有基因中的百分位数，实现将长拖尾数据转化为正态分布。\nrcountsNormVoom &lt;- v0oom(\n  counts = countsNorm,\n  design = design\n)1.2.2 Log2(counts+1)Log2(counts+1) 就其形式而言与 voom 的公式如出一辙；\n由于我们上一步已经进行过 normalizeBetweenArrays() ，因此可以认为  对于所有样本都是相等的，即测序深度归一化；\n因此直接做 Log2(counts+1) 的结果与 voom 的结果仅相差一个比例倍数，其分布应当是完全一致的，计算差异倍数的结果也会是一致的。\nrcountsNormLog &lt;- log2(countsNorm+1)1.2.3 TPM 或 FPKMlimma 理论上可以接受任何标准化方法的输入，因此通常不被 DESeq2 或 edgeR 所接受的 TPM 或 FPKM 数据会交给 limma 处理；\n然而 limma 的官方文件也指出，与 DESeq2 和 edgeR 相同，其在处理 counts 数据时效果是最好的；\n因此一般有 raw counts 数据时，不会转化为 TPM 或 FPKM；\n因而此处只给出 TPM 与 FPKM 的公式，而不给出具体代码。\n其中  代表第 i 个基因转录本的长度，不特指时取最长转录本，若特指某个转录本则使用该转录本的长度\n\n\n观察公式可知，TPM 计算时，求和符号中同时存在  与 ， 因此同时对测序深度与基因长度进行了归一化；\n而 FPKM 在计算时，求和符号中仅有 ， 在求和符号之外，因而其仅对测序深度进行了归一化，而未对基因长度进行归一化。\n1.2.4 标准化方法的选择首先，在有 raw counts 数据的情况下，不选择 TPM 或 FPKM 标准化；\n然后，在前期进行了 normalizeBetweenArrays() 的前提下， voom 和 log2(counts+1) 是等价的；\n但是考虑到前期处理时可能不规范，没有进行 normalizeBetweenArrays()，此时选择 voom 相较之下更为保险；\n之后的分析中也会主要使用 countsNormVoom。\n2. Limma 的标准流程我们现在已经准备好了 countsNormVoom 与 design 两个数据，可以进行 limma 的标准流程。\nr# 建立对比矩阵\n# 我们将对比设置为 PPHLN1-Ctrl，即 PPHLN1 为实验组， Ctrl 为对照组\n# 最后得到的差异倍数也是 log(PPHLN1/Ctrl)\ncontrastsMatrix &lt;- makeContrasts(\n    contrasts = \"PPHLN1-Ctrl\",\n    levels = design\n)\n\n# 线性拟合，通过拟合的线性函数代表基因的平均表达量\nfit &lt;- lmFit(\n    object = countsNormVoom,\n    design = design\n)\n\n# 计算倍数，输入拟合后的结果与对比矩阵，计算两组间的差异倍数\nfit &lt;- contrasts.fit(\n    fit = fit,\n    contrasts = contrastsMatrix\n)\n\n# 通过经验贝叶斯方法对计算结果的标准差进行同比的缩放，以缓和统计分析的结果，使得 t 检验，F 检验等的结果更显著\nfit &lt;- eBayes(fit)\n\n# 从拟合结果中取出差异分析表\nDEG &lt;- topTable(\n  fit,\n  number = Inf\n)\nDEG$gene &lt;- rownames(DEG) # 提取出基因列\n\n# 根据矫正 P 值与差异倍数将差异基因分为上调或下调\nDEG$regulation &lt;- case_when(\n    DEG$adj.P.Val &lt; 0.05 &amp; DEG$logFC &gt; 1 ~ \"up\",\n    DEG$adj.P.Val &lt; 0.05 &amp; DEG$logFC &lt; -1 ~ \"down\",\n    .default = \"ns\"\n)\n\n# 查看最终得到的差异基因的数量\ntable(DEG$regulation)3. 火山图的绘制差异基因通常通过火山图进行呈现；\n此处实验设置只有两组，因此主要介绍两组火山图的绘制；\n之后在讲解单细胞分析的时候会遇到多组间的差异基因，介时会讲解多组火山图的绘制。\n3.1 认识火山图\n坐标轴：\n横轴：log2FC，即差异倍数，越往右越上调，越往左越下调；\n纵轴：-log10(adj.P.Value)，即矫正 P 值，越往上统计学意义越显著\n\n\n分隔线：\n，标记了差异倍数为 1  的位置，在这两条线外侧的基因差异显著；\n，标记了矫正 P 值为 0.05 的位置，在这条线之上的基因具有统计学意义\n\n\n颜色：\n红色：矫正 P 值 &lt; 0.05 且 差异倍数 &gt; 1，代表实验组相对与对照组上调的基因\n蓝色：矫正 P 值 &lt; 0.05 且 差异倍数 &lt; -1，代表实验组相对与对照组下调的基因\n灰色：不符合上述条件，代表无明显差异的基因\n\n\n\n3.2 绘制rpicVolcano &lt;- ggplot(DEG) +\n    # 散点图，标记每个基因的位置\n    geom_point(\n        mapping = aes(\n            x = logFC,\n            y = -log10(adj.P.Val),\n            color = regulation\n        )\n    ) +\n    # 指定颜色\n    scale_color_manual(\n        values = c(\"blue\", \"gray\", \"red\")\n    ) +\n    # 纵分隔线\n    geom_vline(\n        xintercept = c(-1, 1),\n        lty = 5, # 虚线\n        color = \"gray\"\n    ) +\n    # 横分隔线\n    geom_hline(\n        yintercept = -log10(0.05),\n        lty = 5, # 虚线\n        color = \"gray\"\n    ) +\n    # 横纵轴标签与标题\n    labs(\n        x = expression(log[2]*\"(Fold Change)\"),\n        y = expression(-log[10]*\"(Adjusted P Value)\"),\n        title = \"PPHLN1 vs. Ctrl\"\n    ) +\n    # 方框空白主题\n    theme_bw() +\n    # 其他主题设置\n    theme(\n        plot.title = element_text(\n            face = \"bold\", # 标题加粗\n            hjust = 0.5 # 标题居中\n        ),\n        legend.position = \"bottom\" # 图例置于底部\n    )\nprint(picVolcano) # 画图\n\n4. 表达热图的绘制热图表现了差异基因在不同样本间表达量的差异，通常选取与自己研究主题相关的基因进行展示；\n此处因为仅做演示，因此选取高变 2000 个基因进行展示\nr# 按照差异倍数正序与倒序各取前 1000 个基因，总共 2000 个\ntopVar2k &lt;- rbind(\n    DEG[order(DEG$logFC, decreasing = TRUE)[1:1000], ],\n    DEG[order(DEG$logFC, decreasing = FALSE)[1:1000], ]\n)$gene\n\n# 取出这 2000 个基因的表达矩阵\ndat &lt;- countsNormVoom[topVar2k, ]\n\n# 绘制热图\npicHeatmap &lt;- pheatmap(\n    mat = dat,\n    scale = \"row\", # 按行标准化\n    color = colorRampPalette(c(\"blue\", \"white\", \"red\"))(100), # 指定颜色为（蓝，白，红），过渡为 100 级\n    treeheight_row = 0, # 基因方向上的聚类树高度设置为 0，因为此处聚类无意义，因而隐藏起来，\n                        # 若在你的实验中需要看不同基因之间相关性的高低，可以不设置隐藏\n    cutree_cols = 2, # 将样本分为两组，目的在于检查实验组与对照组间是否有混杂\n    show_rownames = FALSE # 不显示基因名，因为此处展示了大量基因，若仅展示少量基因时，应当显示基因名\n)\nplot.new() # 新建画布\nprint(picHeatmap) # 画图","slug":"Limma-差异分析的一般流程","date":"2024-07-15T10:23:34.000Z","categories_index":"生物信息学","tags_index":"生物信息学,R,bulk-seq,差异分析,limma","author_index":"明明钟"},{"id":"8fd9bc806036d8ae8c47b44f69c0de01","title":"RNAseq 数据预处理的常规流程","content":"RNAseq 数据预处理的常规流程目录\n环境设置\n数据展示\n数据质量检测\n过滤低表达基因\n数据标准化\n去批次\n处理后质量检测\n\n0. 环境设置读入本次实验需要用到的数据包。\nrlibrary(tidyverse) # 格式整理\nlibrary(data.table) # 读入文件\nlibrary(clusterProfiler) # Gene ID 转换为 Gene Symbol\nlibrary(org.Hs.eg.db) # 人类基因组注释文件\nlibrary(FactoMineR) # 计算 PCA\nlibrary(factoextra) # PCA 画图\nlibrary(pheatmap) # 热图\nlibrary(ggplot2) # 画图\nlibrary(reshape2) # 长宽表转换\nlibrary(edgeR) # 去除低表达基因 1. 数据展示此次演示中使用来自 GSE222699 的 RNAseq 数据，数据从 GEO 官网下载。\ntxtGSE222699_RAW\n├─ GSM6929162_HDMB03_CTRL_1.txt.gz\n├─ GSM6929163_HDMB03_CTRL_2.txt.gz\n├─ GSM6929164_HDMB03_CTRL_3.txt.gz\n├─ GSM6929165_HDMB03_CTRL_4.txt.gz\n├─ GSM6929166_HDMB03_CTRL_1.txt.gz\n├─ GSM6929167_HDMB03_CTRL_2.txt.gz\n├─ GSM6929168_HDMB03_CTRL_3.txt.gz\n└─ GSM6929169_HDMB03_CTRL_4.txt.gz1.1 读入数据这组数据并没有将所有样本整合为一个表达矩阵，而是每个样本各有一个文件，因此我们首先整理表达矩阵。\nr# 将所有文件列入一个列表\nfiles &lt;- list.files(\n    path = \"data/GSE222699_RAW/\",\n    full.names = TRUE\n)\n\n# 读入列表中的第一个文件作为模板\n# 因为文件属于 .gz 压缩文件，直接用 fread 读入后再转换为 data.frame，这是一种更方便的操作\ncounts &lt;- fread(files[[1]]) %&gt;%\n    as.data.frame()\n\n# 从第二个文件开始，读入后与前几个文件合并\nfor (file in files[2:length(files)]) {\n    tmp &lt;- fread(file) %&gt;%\n        as.data.frame()\n    counts &lt;- merge(counts, tmp, by = \"V1\")\n}\n\n# 查看合并后的表达矩阵\nView(counts)\n\n\n\nV1\nHDMB03_shCTRL_1\nHDMB03_shCTRL_2\nHDMB03_shCTRL_3\nHDMB03_shCTRL_4\nHDMB03_shPPHLN1_1\nHDMB03_shPPHLN1_2\nHDMB03_shPPHLN1_3\nHDMB03_shPPHLN1_4\n\n\n\n1\nENSG00000000003\n1041\n966\n828\n1053\n1334\n1563\n1157\n1258\n\n\n2\nENSG00000000005\n0\n0\n0\n0\n0\n0\n0\n0\n\n\n3\nENSG00000000419\n1118\n1382\n999\n1414\n1140\n1648\n1067\n1168\n\n\n4\nENSG00000000457\n315\n394\n369\n344\n482\n595\n435\n388\n\n\n5\nENSG00000000460\n447\n436\n439\n411\n479\n635\n496\n339\n\n\n6\nENSG00000000938\n0\n0\n0\n0\n0\n0\n0\n0\n\n\n1.2 Gene ID 转换为 Gene Symbol可以看到，合并后的矩阵以 Gene ID 表示基因，这不利于我们后续对基因的阅读，需要转换为方便阅读的 Gene Symbol。\nr# 通过 clusterProfiler 中的 bitr() 函数将 Gene ID 与 Symbol 一一对应\n# drop = FALSE 是指无法 mapping 到 Symbol 的 Gene ID 依然保留在表中，方便后续的合并\n# 如果 drop = TRUE，那么无法 mapping 的 Gene ID 会被舍去，id2symbol 的顺序就会和 counts 不同，不利于合并\nid2symbol &lt;- bitr(\n    geneID = counts$V1,\n    fromType = \"ENSEMBL\",\n    toType = \"SYMBOL\",\n    OrgDb = org.Hs.eg.db,\n    drop = FALSE\n)\n\n# 消除对应到多个 Symbol 的 Gene ID，只保留 mapping 到的第一个 Symbol\n# duplicated() 代表重复的元素，对其取反 !duplicated() 代表不重复的元素\nid2symbol &lt;- id2symbol[which(!duplicated(id2symbol$ENSEMBL)), ]\n\n# 比对 id2symbol 与 counts 是否一一对应\ntable(id2symbol$ENSEMBL == counts$V1) # TRUE\n\n# 将 Gene Symbol 合并入 counts\ncounts$Symbol &lt;- id2symbol$SYMBOL\n\n# 去除没有 mapping 到的 Gene ID\n# na.omit() 去除包含 NA 的行\ncounts &lt;- na.omit(counts)\n\n# 查看 ID 转换后的表达矩阵\nView(counts)\n\n\n\nV1\nHDMB03_shCTRL_1\nHDMB03_shCTRL_2\nHDMB03_shCTRL_3\nHDMB03_shCTRL_4\nHDMB03_shPPHLN1_1\nHDMB03_shPPHLN1_2\nHDMB03_shPPHLN1_3\nHDMB03_shPPHLN1_4\nSymbol\n\n\n\n1\nENSG00000000003\n1041\n966\n828\n1053\n1334\n1563\n1157\n1258\nTSPAN6\n\n\n2\nENSG00000000005\n0\n0\n0\n0\n0\n0\n0\n0\nTNMD\n\n\n3\nENSG00000000419\n1118\n1382\n999\n1414\n1140\n1648\n1067\n1168\nDPM1\n\n\n4\nENSG00000000457\n315\n394\n369\n344\n482\n595\n435\n388\nSCYL3\n\n\n5\nENSG00000000460\n447\n436\n439\n411\n479\n635\n496\n339\nFIRRM\n\n\n6\nENSG00000000938\n0\n0\n0\n0\n0\n0\n0\n0\nFGR\n\n\n1.3 消除重复的基因多个 Gene ID 常常对应到同一个 Gene Symbol，导致矩阵中出现重复的基因名，需要想办法去除。\nr# 去除 Gene ID 这一列\n# [, -1] 代表去除第一列\ncounts &lt;- counts[, -1]\n\n# 取出重复的基因与不重复的基因\n# 查看有多少重复的基因\ntable(duplicated(counts$Symbol))\n\n# 取出重复基因所在的行号\ndupl &lt;- duplicated(counts$Symbol)\n\n# 取出重复的基因名\ngeneDupl &lt;- counts$Symbol[dupl]\n\n# 取出重复的基因所在的行\n# 这边不直接使用 duplicated() 函数，是因为 duplicated() 函数不会取出第一项重复的元素\n# 比如如果一个元素共重复了 5 次， duplicated() 只会取出后 4 次，而忽略第 1 次\ncountsDupl &lt;- subset(\n    x = counts,\n    subset = Symbol %in% geneDupl\n)\n\n# 不在 geneDupl 中的基因则认为是 unique 的基因\ncountsUniq &lt;- subset(\n    x = counts,\n    subset = !(Symbol %in% geneDupl)\n)\n\n# 合并重复的基因\n# 合并的方法有很多种，包括：均数 mean，中位数 median，最大值 max\n# 因为此处的数据类型为 Raw counts，为了尽量保护其整数性，此处选择使用 median\ncountsDupl &lt;- aggregate(\n    x = .~Symbol,\n    data = countsDupl,\n    FUN = median\n)\n\n# 将合并好的重复基因与非重复基因合并，得到完整的表达矩阵\ncounts &lt;- rbind(\n    countsDupl, countsUniq,\n    deparse.level = 2\n)\n\n# 将 Gene Symbol 转换为行名\ncounts &lt;- counts %&gt;%\n    remove_rownames() %&gt;%\n    column_to_rownames(var = \"Symbol\")\n\n# Counts 取整数\n# 即使是使用 median 处理重复基因，也难以避免 .5 的出现，因此依然需要四舍五入 round()\ncounts &lt;- round(counts)\n\n# 查看处理后的表达矩阵\nView(counts)\n\n\n\nHDMB03_shCTRL_1\nHDMB03_shCTRL_2\nHDMB03_shCTRL_3\nHDMB03_shCTRL_4\nHDMB03_shPPHLN1_1\nHDMB03_shPPHLN1_2\nHDMB03_shPPHLN1_3\nHDMB03_shPPHLN1_4\n\n\n\nARL17A\n84\n90\n88\n70\n98\n103\n102\n78\n\n\nBAZ2B\n694\n730\n674\n734\n672\n930\n778\n752\n\n\nBOLA2\n2\n0\n2\n6\n0\n0\n0\n0\n\n\nCCNYL6\n1\n2\n0\n1\n0\n0\n1\n3\n\n\nCKMT1B\n490\n726\n641\n476\n554\n622\n524\n396\n\n\nCRHR1\n22\n18\n32\n40\n24\n43\n36\n26\n\n\n2. 数据质量检测2.0 分组该数据共分为 2 组，4 个对照组 Ctrl 与 4 个实验组 PPHLN1。\nrgroup &lt;- data.frame(\n    group = rep(\n        x = c(\"Ctrl\", \"PPHLN1\"), # 2 组\n        each = 4 # 各 4 个\n    ),\n    row.names = colnames(counts) # 行名即样本名\n)2.1 PCAPCA （主成分分析）是一种数据降维方法。\n\n首先，所有的数据以其每个基因为基底，张成一个高维空间，而每个样本在这个高维空间中具有一个唯一的坐标 (x1, x2, … , xn)：\n计算高维空间中各个方向上样本间的方差，取方差最大的方向上的向量作为其主成分向量，记作 PC_1；\n显然，在 PC_1 上，样本的分布最为分散，不同样本间的区分度也就最高；\n\n\n在垂直于 PC_1 的各个方向上，取方差最大的方向上的向量，记作 PC_2：\nPC_1 与 PC_2 共同张成一个正交的二维平面；\n显然，在这一平面上，各个样本间的分布最为分散，不同样本间的区分度也就最高；\n\n\n在由 PC_1 与 PC_2 张成的二维平面上考察不同分组的样本的分布模式，理想的情况下：\n处于同一分组的样本之间的位置最为接近；\n处于不同分组的样本之间的位置相距最远。\n\n\n\nrpcaBefore &lt;- PCA(\n    X = t(counts),\n    graph = FALSE # 计算时不画图\n)\npicPcaBefore &lt;- fviz_pca_ind(\n    X = pcaBefore,\n    col.ind = group$group, # 规定各组的颜色\n    repel = TRUE, # 文字标签之间不重叠\n    addEllipses = TRUE # 加入椭圆形，每组不多于 3 个样本时无法加入椭圆\n                       # （五点确定一个椭圆，因此至少需要五个自由度，而对于不精确的拟合，可以只用 4 个点）\n)\nprint(picPcaBefore)\n\n2.2 相关性热图计算各个样本之间的相关性，以热图的形式展示，理想情况下：\n\n同属一组的样本之间相关性最高；\n属于不同组的样本之间相关性最低。\n\nrpicHeatmapBefore &lt;- pheatmap(\n    mat = counts %&gt;% cor(), # 计算相关性矩阵\n    annotation_row = group, # 行色块标签，表示分组\n    annotation_col = group, # 列色块标签，表示分组\n    legend = TRUE, # 显示色条图注\n    annotation_legend = FALSE, # 不显示分组图注\n    cutree_rows = 2, # 根据树状图分为两行\n    cutree_cols = 2, # 根据树状图分为两列\n    color = colorRampPalette(c(\"blue\", \"white\", \"red\"))(100) # 规定颜色为 (蓝, 白, 红)，过渡为 100\n)\nplot.new() # 新建画布\nprint(picHeatmapBefore) # 画图\n\n2.3 箱线图通过箱线图表示各个样本的分布，以考察各个样本是否属于同分布；\n若样本间的分布不同，不利于后续的统计学分析，需要进行标准化；\n由于 Raw counts 符合负二项分布，因此需要取 log2(counts+1) 使其接近正态分布。\nrpicBoxplotBefore &lt;- (counts+1) %&gt;% log2() %&gt;% # 取 log2(counts+1)\n    melt() %&gt;% # 将宽表形式的表达矩阵转换为长表形式，便于画图\n    ggplot + # 画图开始\n    geom_boxplot( # 画箱线图\n        mapping = aes(\n            x = variable, # x 轴为样本\n            y = value # y 轴为基因表达量\n        )\n    ) +\n    labs(x = \"Sample\", y = \"Expression\") + # 指定 x 轴与 y 轴的标题\n    theme_bw() + # 方框空白主题\n    theme(\n        axis.text.x = element_text(angle = 45, hjust = 1) # x 轴标签旋转 45 度并右对齐\n    )\nplot.new() # 新建画布\nprint(picBoxplotBefore) # 画图\n\n3. 过滤低表达基因观察到箱线图中的中位数线位于 0，说明存在大量低表达甚至不表达的基因；\n考虑到  无意义，会影响后续的差异倍数的计算；\n因此需要去除低表达的基因；\n此处使用 edgeR 包中的 filterByExpr() 函数。\nr# 过滤低表达基因\nkeep &lt;- filterByExpr(\n    counts,\n    group = group$group\n)\n\n# 取出过滤后仍保留的行\ncountsRLE &lt;- counts[keep, ]\n\n# 制图\npicBoxplotRLE &lt;- (countsRLE+1) %&gt;% log2() %&gt;% # log2(counts+1)\n    melt() %&gt;%\n    ggplot +\n    geom_boxplot(\n        mapping = aes(\n            x = variable,\n            y = value\n        )\n    ) +\n    labs(x = \"Sample\", y = \"Expression\") +\n    theme_bw() +\n    theme(\n        axis.text.x = element_text(angle = 45, hjust = 1)\n    )\n\n# 画图\nprint(picBoxplotRLE)\n\n经过过滤低表达基因后，可以看到，箱线图中的中位数线位于箱子的正中间，说明现在的表达量分布接近正态分布。\n4. 数据标准化观察经过过滤后的箱线图，可以发现，虽然大体上的分布趋势相似，但是箱子的高度仍然有细微的差别；\n我们可以使用 limma 包中的 normalizeBetweenArrays() 函数进行优化\nrcountsNorm &lt;- normalizeBetweenArrays(countsRLE)\npicBoxplotAfter &lt;- (countsNorm+1) %&gt;% log2() %&gt;%\n    melt() %&gt;%\n    ggplot +\n    geom_boxplot(\n        mapping = aes(\n            x = Var2,\n            y = value\n        )\n    ) +\n    labs(x = \"Sample\", y = \"Expression\") +\n    theme_bw() +\n    theme(\n        axis.text.x = element_text(angle = 45, hjust = 1)\n    )\nprint(picBoxplotAfter)\n\n可以看到，经过标准化后的数据分布完全一致，有利于我们下一步的分析\n5. 去批次此次实验中的样本全部来自一次测序结果，因此不存在批次效应；\n若实验中的样本是多次测序汇总的结果，则不同的测序批次之间存在批次效应，需要去除；\n去除批次效应可以使用 sva 包中的 ComBat() 函数以及 limma 包中的 removeBatchEffect() 函数；\n因为后续的差异分析主要基于 limma 包，因此此处也主要介绍 limma 包中的方法。\nr# 将分组信息转化为实验设计矩阵\ndesign &lt;- model.matrix(~0+group$group)\n\n# 提供批次信息\nbatch &lt;- data.frame(\n    batch = c(...) # 此处填入批次信息\n    row.names = col.names(countsNorm) # 行名来自样本名\n)\n\n# 去批次\ncountsRBE &lt;- removeBatchEffect(\n    counts,\n    batch = batch$batch, # 去除批次效应\n    design = design # 保留生物学效应\n)去批次后，可以再使用 PCA 方法验证去批次的效果。\n6. 处理后质量检测同样使用 PCA、相关性热图、箱线图三种方法；\n代码不赘述\n\n\n\n\n","slug":"RNAseq-数据预处理的常规流程","date":"2024-07-12T06:54:56.000Z","categories_index":"生物信息学","tags_index":"生物信息学,bulk-seq,数据预处理","author_index":"明明钟"}]